<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <title>B·∫£n ƒë·ªì MobiFiber</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- Google Visualization -->
  <script src="https://www.gstatic.com/charts/loader.js"></script>

  <!-- SheetJS -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

  <style>
    html, body { height: 100%; margin: 0; }
    #map { width: 100%; height: 100%; }

    .control-box {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 1000;
      background: white;
      padding: 10px 12px;
      border-radius: 6px;
      box-shadow: 0 0 6px rgba(0,0,0,0.3);
      font-size: 13px;
      min-width: 240px;
    }

    .panel-title {
      font-weight: bold;
      margin-bottom: 6px;
    }

    .search-row {
      display: flex;
      gap: 4px;
      margin-bottom: 6px;
    }

    .search-row input { flex: 1; }

    .legend {
      margin-top: 6px;
      border-top: 1px solid #eee;
      padding-top: 6px;
    }

    .legend div { margin-bottom: 4px; }

    .blink {
      animation: blink 1s infinite;
    }

    @keyframes blink {
      0% { opacity: 1; }
      50% { opacity: 0.3; }
      100% { opacity: 1; }
    }
  </style>
</head>
<body>

<div class="control-box">
  <div class="panel-title">T√¨m t·∫≠p ƒëi·ªÉm g·∫ßn kh√°ch h√†ng</div>

  <div class="search-row">
    <input id="searchInput" placeholder="Nh·∫≠p t·ªça ƒë·ªô ho·∫∑c ƒë·ªãa ch·ªâ">
    <button onclick="searchLocation()">T√¨m</button>
  </div>

  <div>
    <div><b>Hi·ªÉn th·ªã theo hi·ªáu su·∫•t s·ª≠ d·ª•ng</b></div>
    <select id="filterSelect" onchange="applyFilter()" style="width:100%">
      <option value="all">T·∫•t c·∫£</option>
      <option value="lt20">&lt; 20%</option>
      <option value="20_50">20‚Äì50%</option>
      <option value="50_80">50‚Äì80%</option>
      <option value="gte80">&ge; 80%</option>
    </select>
  </div>

  <div class="legend">
    <div class="legend-note">Hi·ªáu su·∫•t s·ª≠ d·ª•ng t·∫≠p ƒëi·ªÉm</div>
    <div>üîµ &lt;20%</div>
    <div>üü¢ 20‚Äì50%</div>
    <div>üü° 50‚Äì80%</div>
    <div>üî¥ 80‚Äì&lt;100%</div>
    <div>‚ö´ ‚â•100%</div>
  </div>

  <div style="margin-top:6px">
    <button onclick="exportUpgradeList()" style="width:100%">
      Xu·∫•t DS t·∫≠p ƒëi·ªÉm c·∫ßn n√¢ng c·∫•p
    </button>
  </div>
</div>

<div id="map"></div>

<script>
/* ================= GLOBAL ================= */

const SHEET_URL = 'https://docs.google.com/spreadsheets/d/1avvicsQgJIm_D66EsPxFE7aUBCfuMdBq';
const SHEET_NAME = 'Danh s√°ch t·∫≠p ƒëi·ªÉm S2';

let map;
let allPoints = [];
let customerMarker = null;
let suggestionLayers = [];
let isInitialLoad = true;

/* ================= MAP ================= */

map = L.map('map', { zoomControl: false }).setView([10.8, 106.7], 11);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19 }).addTo(map);

/* ================= UTILS ================= */

function validateLatLng(lat, lng) {
  if (lat === null || lat === undefined) return false;
  if (lng === null || lng === undefined) return false;

  if (String(lat).trim() === "") return false;
  if (String(lng).trim() === "") return false;

  lat = Number(lat);
  lng = Number(lng);

  if (!Number.isFinite(lat) || !Number.isFinite(lng)) return false;

  // ‚úÖ B·ªî SUNG D√íNG N√ÄY ‚Äì CH·ªêT H·∫†
  if (lat === 0 && lng === 0) return false;

  return lat >= -90 && lat <= 90 && lng >= -180 && lng <= 180;
}

function getColor(eff) {
  if (eff < 0.2) return 'blue';
  if (eff < 0.5) return 'green';
  if (eff < 0.8) return 'yellow';
  if (eff < 1) return 'red';
  return 'black';
}

function haversine(lat1, lng1, lat2, lng2) {
  const R = 6371000;
  const toRad = d => d * Math.PI / 180;
  const dLat = toRad(lat2 - lat1);
  const dLng = toRad(lng2 - lng1);
  const a = Math.sin(dLat/2)**2 +
    Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
    Math.sin(dLng/2)**2;
  return 2 * R * Math.asin(Math.sqrt(a));
}

/* ================= LOAD DATA ================= */

google.charts.load('current', { packages: ['corechart'] });
google.charts.setOnLoadCallback(loadData);

function loadData() {
  const query = new google.visualization.Query(
    `${SHEET_URL}/gviz/tq?sheet=${encodeURIComponent(SHEET_NAME)}`
  );

  query.send(res => {
    const data = res.getDataTable();
    for (let i = 0; i < data.getNumberOfRows(); i++) {
      const lat = Number(data.getValue(i, 9));
      const lng = Number(data.getValue(i, 10));
      if (!validateLatLng(lat, lng)) continue;

      const eff = Number(data.getValue(i, 7));

      const circle = L.circle([lat, lng], {
        radius: 300,
        color: getColor(eff),
        fillColor: getColor(eff),
        fillOpacity: 0.5,
        weight: 2
      });

      circle.bindPopup(`
        <b>${data.getValue(i, 2)}</b><br>
        Dung l∆∞·ª£ng: ${data.getValue(i, 3)}<br>
        ƒê√£ d√πng: ${data.getValue(i, 4)}<br>
        C√≤n l·∫°i: ${data.getValue(i, 5)}<br>
        Hi·ªáu su·∫•t: ${(eff * 100).toFixed(1)}%
      `);

      allPoints.push({
        name: data.getValue(i, 2),
        maxPort: data.getValue(i, 3),
        usedPort: data.getValue(i, 4),
        freePort: data.getValue(i, 5),
        eff, lat, lng,
        circle
      });
    }
    renderPoints();
  });
}

/* ================= RENDER ================= */

function renderPoints() {
  const bounds = [];
  allPoints.forEach(p => {
    p.circle.addTo(map);
    bounds.push([p.lat, p.lng]);
  });

  if (isInitialLoad && bounds.length) {
    map.fitBounds(bounds, { padding: [40, 40] });
    isInitialLoad = false;
  }
}

/* ================= FILTER ================= */

function applyFilter() {
  const v = filterSelect.value;
  allPoints.forEach(p => {
    let show = true;
    if (v === 'lt20') show = p.eff < 0.2;
    else if (v === '20_50') show = p.eff >= 0.2 && p.eff < 0.5;
    else if (v === '50_80') show = p.eff >= 0.5 && p.eff < 0.8;
    else if (v === 'gte80') show = p.eff >= 0.8;
    show ? p.circle.addTo(map) : map.removeLayer(p.circle);
  });
}

/* ================= SEARCH ================= */

function searchLocation() {
  const val = searchInput.value.trim();
  if (!val) return;

  const p = val.split(',');
  if (p.length === 2 && !isNaN(p[0]) && !isNaN(p[1])) {
    handleCustomer(+p[0], +p[1]);
    return;
  }

  fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(val)}`)
    .then(r => r.json())
    .then(r => r[0] && handleCustomer(+r[0].lat, +r[0].lon));
}

/* ================= CUSTOMER & SUGGEST ================= */

function handleCustomer(lat, lng) {
  if (customerMarker) map.removeLayer(customerMarker);
  suggestionLayers.forEach(l => map.removeLayer(l));
  suggestionLayers = [];

  allPoints.forEach(p => {
    p.circle.setStyle({ weight: 2 });
    const el = p.circle.getElement();
    if (el) el.classList.remove('blink');
  });

  customerMarker = L.marker([lat, lng]).addTo(map);
  map.setView([lat, lng], 15);

  const candidates = allPoints
    .filter(p => p.freePort > 0)
    .map(p => ({ ...p, dist: haversine(lat, lng, p.lat, p.lng) }))
    .sort((a, b) => a.dist - b.dist || a.eff - b.eff)
    .slice(0, 3);

  candidates.forEach((p, i) => {
    const el = p.circle.getElement();
    if (el) el.classList.add('blink');

    p.circle.setStyle({ weight: 4 });

    const line = L.polyline(
      [[lat, lng], [p.lat, p.lng]],
      { color: 'green', dashArray: '5,5' }
    ).addTo(map);

    line.bindTooltip(`${Math.round(p.dist)} m`, { permanent: true, direction: 'center' });

    p.circle.bindPopup(`
      <b>${p.name}</b><br>
      Dung l∆∞·ª£ng: ${p.maxPort}<br>
      ƒê√£ d√πng: ${p.usedPort}<br>
      C√≤n l·∫°i: ${p.freePort}<br>
      Hi·ªáu su·∫•t: ${(p.eff * 100).toFixed(1)}%<br>
      <b>Kho·∫£ng c√°ch:</b> ${Math.round(p.dist)} m<br>
      ${i === 0 ? '<b style="color:green">‚≠ê T·∫¨P ƒêI·ªÇM T·ªêT NH·∫§T</b>' : ''}
    `);

    suggestionLayers.push(line);
  });
}

/* ================= EXPORT ================= */

function exportUpgradeList() {
  const rows = [['T√™n', 'Lat', 'Lng', 'Hi·ªáu su·∫•t (%)', '∆Øu ti√™n']];
  allPoints.forEach(p => {
    if (p.eff >= 0.8) {
      rows.push([
        p.name, p.lat, p.lng,
        (p.eff * 100).toFixed(1),
        p.eff >= 1 ? '∆Øu ti√™n 1' : '∆Øu ti√™n 2'
      ]);
    }
  });

  const wb = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(wb, XLSX.utils.aoa_to_sheet(rows), 'Upgrade');
  XLSX.writeFile(wb, 'tap_diem_can_nang_cap.xlsx');
}
</script>

</body>
</html>








